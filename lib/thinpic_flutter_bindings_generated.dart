// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/thinpic_flutter.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class ThinpicFlutterBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ThinpicFlutterBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ThinpicFlutterBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// Main compression functions
  CompressedImageResult compress_image(
    ffi.Pointer<ffi.Char> input_path,
    int quality,
  ) {
    return _compress_image(input_path, quality);
  }

  late final _compress_imagePtr =
      _lookup<
        ffi.NativeFunction<
          CompressedImageResult Function(ffi.Pointer<ffi.Char>, ffi.Int)
        >
      >('compress_image');
  late final _compress_image = _compress_imagePtr
      .asFunction<CompressedImageResult Function(ffi.Pointer<ffi.Char>, int)>();

  /// New function with optional width and height parameters
  /// If both width and height are provided, the smallest dimension will be used to maintain aspect ratio
  /// If only one is provided, the other will be calculated to maintain aspect ratio
  /// If both are 0 or negative, no resizing will be applied
  CompressedImageResult compress_image_with_size(
    ffi.Pointer<ffi.Char> input_path,
    int quality,
    int target_width,
    int target_height,
  ) {
    return _compress_image_with_size(
      input_path,
      quality,
      target_width,
      target_height,
    );
  }

  late final _compress_image_with_sizePtr =
      _lookup<
        ffi.NativeFunction<
          CompressedImageResult Function(
            ffi.Pointer<ffi.Char>,
            ffi.Int,
            ffi.Int,
            ffi.Int,
          )
        >
      >('compress_image_with_size');
  late final _compress_image_with_size = _compress_image_with_sizePtr
      .asFunction<
        CompressedImageResult Function(ffi.Pointer<ffi.Char>, int, int, int)
      >();

  CompressedImageResult compress_large_image(
    ffi.Pointer<ffi.Char> input_path,
    int quality,
  ) {
    return _compress_large_image(input_path, quality);
  }

  late final _compress_large_imagePtr =
      _lookup<
        ffi.NativeFunction<
          CompressedImageResult Function(ffi.Pointer<ffi.Char>, ffi.Int)
        >
      >('compress_large_image');
  late final _compress_large_image = _compress_large_imagePtr
      .asFunction<CompressedImageResult Function(ffi.Pointer<ffi.Char>, int)>();

  CompressedImageResult compress_large_dslr_image(
    ffi.Pointer<ffi.Char> input_path,
    int quality,
  ) {
    return _compress_large_dslr_image(input_path, quality);
  }

  late final _compress_large_dslr_imagePtr =
      _lookup<
        ffi.NativeFunction<
          CompressedImageResult Function(ffi.Pointer<ffi.Char>, ffi.Int)
        >
      >('compress_large_dslr_image');
  late final _compress_large_dslr_image = _compress_large_dslr_imagePtr
      .asFunction<CompressedImageResult Function(ffi.Pointer<ffi.Char>, int)>();

  CompressedImageResult smart_compress_image(
    ffi.Pointer<ffi.Char> input_path,
    int target_kb,
    int type,
  ) {
    return _smart_compress_image(input_path, target_kb, type);
  }

  late final _smart_compress_imagePtr =
      _lookup<
        ffi.NativeFunction<
          CompressedImageResult Function(
            ffi.Pointer<ffi.Char>,
            ffi.Int,
            ffi.Int,
          )
        >
      >('smart_compress_image');
  late final _smart_compress_image = _smart_compress_imagePtr
      .asFunction<
        CompressedImageResult Function(ffi.Pointer<ffi.Char>, int, int)
      >();

  /// Image info
  ImageInfo get_image_info(ffi.Pointer<ffi.Char> input_path) {
    return _get_image_info(input_path);
  }

  late final _get_image_infoPtr =
      _lookup<ffi.NativeFunction<ImageInfo Function(ffi.Pointer<ffi.Char>)>>(
        'get_image_info',
      );
  late final _get_image_info = _get_image_infoPtr
      .asFunction<ImageInfo Function(ffi.Pointer<ffi.Char>)>();

  /// Utility
  void free_compressed_buffer(ffi.Pointer<ffi.Uint8> buffer) {
    return _free_compressed_buffer(buffer);
  }

  late final _free_compressed_bufferPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Uint8>)>>(
        'free_compressed_buffer',
      );
  late final _free_compressed_buffer = _free_compressed_bufferPtr
      .asFunction<void Function(ffi.Pointer<ffi.Uint8>)>();

  void shutdown_vips() {
    return _shutdown_vips();
  }

  late final _shutdown_vipsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('shutdown_vips');
  late final _shutdown_vips = _shutdown_vipsPtr.asFunction<void Function()>();

  int test_vips_basic() {
    return _test_vips_basic();
  }

  late final _test_vips_basicPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('test_vips_basic');
  late final _test_vips_basic = _test_vips_basicPtr
      .asFunction<int Function()>();
}

final class CompressedImageResult extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Size()
  external int length;

  @ffi.Int()
  external int success;
}

final class ImageInfo extends ffi.Struct {
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  @ffi.Int()
  external int bands;

  @ffi.Int()
  external int orientation;

  @ffi.Int()
  external int needs_resize;

  @ffi.Int()
  external int new_width;

  @ffi.Int()
  external int new_height;
}
